---
title: "Type Members"
slug: "09_dotnet/0_c/0_getting_started/2_type_members"
stack: "C#.NET"
---

The members of a `class` are either **static members** or **instance members**.

- _Static members_ belong to classes
- _Instance members_ belong to objects (instances of classes).

The following list provides an overview of the kinds of members a class can contain.

```markdown markmap
- Constants
    - Constant values associated with the class
- Fields
    - Variables that are associated with the class
- Properties
    - Actions associated with reading and writing named properties of the class
- Indexers
    - Actions associated with indexing instances of the class like an array
- Operators
    - Conversions and expression operators supported by the class
- Finalizers
    - Actions done before instances of the class are permanently discarded
- Constructors
    - Actions required to initialize instances of the class or the class itself
- Methods
    - Actions that can be performed by the class
- Events
    - Notifications that can be generated by the class
- Types
    - Nested types declared by the class

```

### Constants

> Constants are immutable values which are known at compile time and do not change for the life of the program.

- Constants are declared with the `const` modifier.
- Only the C# built-in types may be declared as const. Reference type constants other than String can only be initialized with a null value. User-defined types, including classes, structs, and arrays, cannot be const.
- Use the `readonly` modifier to create a class, struct, or array that is initialized one time at run time (for example in a constructor) and thereafter cannot be changed.

> C# does not support const methods, properties, or events.

> The enum type enables you to define named constants for integral built-in types (for example int, uint, long, and so on). For more information, see enum.

Constants must be initialized as they are declared. For example:

```csharp
class Calendar1
{
    public const int Months = 12;
}
```

In this example, the constant `Months` is always 12, and it cannot be changed even by the class itself. In fact, when the compiler encounters a constant identifier in C# source code (for example, Months), it substitutes the literal value directly into the intermediate language (IL) code that it produces. Because there is no variable address associated with a constant at run time, const fields cannot be passed by reference and cannot appear as an l-value in an expression.

Multiple constants of the same type can be declared at the same time, for example:

```csharp
class Calendar2
{
    public const int Months = 12, Weeks = 52, Days = 365;
}
```

The expression that is used to initialize a constant can refer to another constant if it does not create a circular reference. For example:

```csharp
class Calendar3
{
    public const int Months = 12;
    public const int Weeks = 52;
    public const int Days = 365;

    public const double DaysPerWeek = (double) Days / (double) Weeks;
    public const double DaysPerMonth = (double) Days / (double) Months;
}
```

`Constants can be marked` as `public`, `private`, `protected`, `internal`, `protected internal` or `private protected`. These access modifiers define how users of the class can access the constant. For more information, see [Access Modifiers](https://learn.microsoft.com/en-us/09_dotnet/csharp/programming-guide/classes-and-structs/access-modifiers).

Constants are accessed as if they were [static](https://learn.microsoft.com/en-us/09_dotnet/csharp/language-reference/keywords/static) fields because the value of the constant is the same for all instances of the type. You do not use the static keyword to declare them. Expressions that are not in the class that defines the constant must use the class name, a period, and the name of the constant to access the constant. For example:

```csharp
int birthstones = Calendar.Months;
```

### Field

A `field` is a variable that is associated with a class or with an instance of a class.

A `field` declared with the `static` modifier defines a _static field_. A _static field_ identifies exactly one storage location. No matter how many instances of a class are created, there's only ever one copy of a static field.

A `field` declared without the `static` modifier defines an _instance field_. Every instance of a class contains a separate copy of all the instance fields of that class.

In the following example, each instance of the Color class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:

```csharp{3-7, 9-11}
public class Color
{
    public static readonly Color Black = new(0, 0, 0);
    public static readonly Color White = new(255, 255, 255);
    public static readonly Color Red = new(255, 0, 0);
    public static readonly Color Green = new(0, 255, 0);
    public static readonly Color Blue = new(0, 0, 255);

    public byte R;
    public byte G;
    public byte B;

    public Color(byte r, byte g, byte b)
    {
        R = r;
        G = g;
        B = b;
    }
}
```

As shown in the previous example, `read-only fields` may be declared with a `readonly` modifier. Assignment to a read-only field can only occur as part of the _field's declaration_ or in a _constructor in the same class_.

### Properties

_Properties_ are a natural extension of fields.

- Both are named members with associated types, and the syntax for accessing fields and properties is the same.
- However, unlike fields, properties don't denote storage locations.
- Instead, properties have accessors that specify the statements executed when their values are read or written. A `get` accessor reads the value. A `set` accessor writes the value.

A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.

- A property that has both a get accessor and a set accessor is a **read-write property**.
- A property that has only a get accessor is a **read-only property**.
- A property that has only a set accessor is a **write-only property**.

- A `get` accessor corresponds to a parameterless method with
  - a return value of the property type.
- A `set` accessor corresponds to a method with

  - a single parameter named value and no return type.

- The get accessor _computes the value of the property_.
- The set accessor _provides a new value for the property_.

- When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.
- In other cases where the property is referenced, the get accessor is invoked.

The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively. The following code is an example of use of these properties:

```csharp
MyList<string> names = new();
names.Capacity = 100;   // Invokes set accessor
int i = names.Count;    // Invokes get accessor
int j = names.Capacity; // Invokes get accessor
```

- Similar to fields and methods, C# supports both `instance properties` and `static properties`.
- Static properties are declared with the static modifier, and instance properties are declared without it.

The accessor(s) of a property can be `virtual`. When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.

### Indexers

- An indexer is a member that enables objects to be indexed in the same way as an array.
- An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.
- The parameters are available in the accessor(s) of the indexer.
- Similar to properties, indexers can be _read-write_, _read-only_, and _write-only_, and the accessor(s) of an indexer can be virtual.

The `MyList<T>` class declares a single read-write indexer that takes an int parameter.
The indexer makes it possible to index `MyList<T>` instances with int values.

For example:

```csharp{7,8}
MyList<string> names = new();
names.Add("Liz");
names.Add("Martha");
names.Add("Beth");
for (int i = 0; i < names.Count; i++)
{
    string s = names[i];
    names[i] = s.ToUpper();
}
```

Indexers can be overloaded. A class can declare multiple indexers as long as the number or types of their parameters differ.

### Operators

An _operator_ is a member that defines the meaning of applying a particular expression operator to instances of a class.
Three kinds of operators can be defined:

1. Unary operators,
2. Binary operators
3. Conversion operators.

All operators must be declared as public and static.

The `MyList<T>` class declares two operators, operator `==` and operator `!=`. These overridden operators give new meaning to expressions that apply those operators to `MyList` instances. Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods. The following example uses the == operator to compare two `MyList<int>` instances.

```csharp
MyList<int> a = new();
a.Add(1);
a.Add(2);
MyList<int> b = new();
b.Add(1);
b.Add(2);
Console.WriteLine(a == b);  // Outputs "True"
b.Add(3);
Console.WriteLine(a == b);  // Outputs "False"
```

The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order. Had `MyList<T>` not defined operator `==`, the first Console.`WriteLine` would have output `False` because a and b reference different `MyList<int>` instances.

For the complete list of C# operators ordered by precedence level, see [C# operators](https://learn.microsoft.com/en-us/09_dotnet/csharp/language-reference/operators/).

### Finalizers

A _finalizer_ is a member that implements the actions required to finalize an instance of a class. Typically, a finalizer is needed to release unmanaged resources.

Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly. The finalizer for an instance is invoked automatically during garbage collection. For more information, see the article on [finalizers](https://learn.microsoft.com/en-us/09_dotnet/csharp/programming-guide/classes-and-structs/finalizers).

The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers. Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread. For these and other reasons, classes should implement finalizers only when no other solutions are feasible.

The using statement provides a better approach to object destruction.

### Constructors

C# supports both `instance` and `static` constructors.

- An `instance constructor` is a member that implements the actions required to initialize an instance of a class.
- A `static constructor` is a member that implements the actions required to initialize a class itself when it's first loaded.

A constructor is declared like a method with no return type and the same name as the containing class. If a constructor declaration includes a static modifier, it declares a static constructor. Otherwise, it declares an instance constructor.

Instance constructors can be overloaded and can have optional parameters. For example, the MyList<T> class declares one instance constructor with a single optional int parameter. Instance constructors are invoked using the new operator. The following statements allocate two MyList<string> instances using the constructor of the MyList class with and without the optional argument.

```csharp
MyList<string> list1 = new();
MyList<string> list2 = new(10);
```

Unlike other members, instance constructors aren't inherited. A class has no instance constructors other than those constructors actually declared in the class. If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.

### Methods

A method is a member that implements a `computation` or `action` that can be performed by an object or class.

- _Static methods_ are accessed directly through the `class`.

```csharp
    Console.Writeline("Foo");
```

- _Instance methods_ are accessed through `instances` of the class.

```csharp
public class MyClass{
    public void LogMessage(){
        Console.WriteLine("Foo")
    }
}
var obj = MyClass();
obj.LogMessage()

```

Methods may have a list of parameters, which represent values or variable references passed to the method. Methods have a return type, which specifies the type of the value computed and returned by the method. A method's return type is void if it doesn't return a value.

Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called. Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.

The signature of a method must be unique in the class in which the method is declared. The signature of a method consists of the following:

- The _name of the method_
- The _number, modifiers, and types of its parameters_
- The _number of type parameters_ in generic methods.

The signature of a method doesn't include the return type.

When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:

```csharp
public override string ToString() => "This is an object";
```

#### Parameters

Parameters are used to pass `values` or `variable references` to methods. The parameters of a method get their actual values from the arguments that are specified when the method is invoked. There are four kinds of parameters: `value parameters`, `reference parameters`, `output parameters`, and `parameter arrays`.

A value parameter is used for passing input arguments. A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter. Modifications to a value parameter don't affect the argument that was passed for the parameter.

Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.

A reference parameter is used for passing arguments by reference. The argument passed for a reference parameter must be a variable with a definite value. During execution of the method, the reference parameter represents the same storage location as the argument variable. A reference parameter is declared with the ref modifier. The following example shows the use of ref parameters.

```csharp
static void Swap(ref int x, ref int y)
{
    int temp = x;
    x = y;
    y = temp;
}

public static void SwapExample()
{
    int i = 1, j = 2;
    Swap(ref i, ref j);
    Console.WriteLine($"{i} {j}");    // "2 1"
}
```

An output parameter is used for passing arguments by reference. It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument. An output parameter is declared with the `out` modifier.

The following example shows the use of `out` parameters.

```csharp
static void Divide(int x, int y, out int quotient, out int remainder)
{
    quotient = x / y;
    remainder = x % y;
}

public static void OutUsage()
{
    Divide(10, 3, out int quo, out int rem);
    Console.WriteLine($"{quo} {rem}");	// "3 1"
}
```

A parameter array permits a variable number of arguments to be passed to a method. A parameter array is declared with the `params` modifier. Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type. The `Write` and `WriteLine` methods of the System.Console class are good examples of parameter array usage. They're declared as follows.

```csharp
public class Console
{
    public static void Write(string fmt, params object[] args) { }
    public static void WriteLine(string fmt, params object[] args) { }
    // ...
}
```

Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type. However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array. In the latter case, an array instance is automatically created and initialized with the given arguments.

This example

```csharp
int x, y, z;
x = 3;
y = 4;
z = 5;
Console.WriteLine("x={0} y={1} z={2}", x, y, z);
```

is equivalent to writing the following.

```csharp
int x = 3, y = 4, z = 5;

string s = "x={0} y={1} z={2}";
object[] args = new object[3];
args[0] = x;
args[1] = y;
args[2] = z;
Console.WriteLine(s, args);
```

#### Method body and local variables

A method's body specifies the statements to execute when the method is invoked.

A method body can declare variables that are specific to the invocation of the method. Such variables are called local variables. A local variable declaration specifies a type name, a variable name, and possibly an initial value. The following example declares a local variable i with an initial value of zero and a local variable j with no initial value.

```csharp
class Squares
{
    public static void WriteSquares()
    {
        int i = 0;
        int j;
        while (i < 10)
        {
            j = i * i;
            Console.WriteLine($"{i} x {i} = {j}");
            i++;
        }
    }
}
```

C# requires a local variable to be definitely assigned before its value can be obtained. For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.

A method can use return statements to return control to its caller. In a method returning void, return statements can't specify an expression. In a method returning non-void, return statements must include an expression that computes the return value.

#### Static and instance methods

A method declared with a `static` modifier is a _static method_. A _static method_ doesn't operate on a specific instance and can only directly access static members.

A method declared without a `static` modifier is an _instance method_. An instance method operates on a specific instance and can access both static and instance members. The instance on which an instance method was invoked can be explicitly accessed as `this`. It's an error to refer to `this` in a static method.

The following Entity class has both static and instance members.

```csharp
class Entity
{
    static int s_nextSerialNo;
    int _serialNo;

    public Entity()
    {
        _serialNo = s_nextSerialNo++;
    }

    public int GetSerialNo()
    {
        return _serialNo;
    }

    public static int GetNextSerialNo()
    {
        return s_nextSerialNo;
    }

    public static void SetNextSerialNo(int value)
    {
        s_nextSerialNo = value;
    }
}
```

Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here). The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number. Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.

The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the s_nextSerialNo static field, but it would be an error for them to directly access the `_serialNo` instance field.

The following example shows the use of the Entity class.

```csharp
Entity.SetNextSerialNo(1000);
Entity e1 = new();
Entity e2 = new();
Console.WriteLine(e1.GetSerialNo());          // Outputs "1000"
Console.WriteLine(e2.GetSerialNo());          // Outputs "1001"
Console.WriteLine(Entity.GetNextSerialNo());  // Outputs "1002"
```

The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the GetSerialNo instance method is invoked on instances of the class.

#### Virtual, override, and abstract methods

You use `virtual`, `override`, and `abstract` methods to define the behavior for a hierarchy of class types.

- Because a class can derive from a base class, those derived classes may need to modify the behavior implemented in the base class.
- A **virtual method** is one declared and implemented in a base class where any derived class may provide a more specific implementation.
- An **override method** is a method implemented in a derived class that modifies the behavior of the base class' implementation.
- An **abstract method** is a method declared in a base class that must be overridden in all derived classes. In fact, abstract methods don't define an implementation in the base class.

Method calls to instance methods may resolve to either base class or derived class implementations.

- The type of a variable determines its _compile-time type_. The compile-time type is the type the compiler uses to determine its members.
- However, a variable may be assigned to an instance of any type derived from its compile-time type. The run-time type is the type of the actual instance a variable refers to.

- When a _virtual method_ is invoked, the run-time type of the instance for which that invocation takes place determines the actual method implementation to invoke.
- In a _nonvirtual method_ invocation, the compile-time type of the instance is the determining factor.

A _virtual method_ can be **overridden** in a derived class.

- When an _instance method_ declaration includes an `override` modifier, the method overrides an _inherited virtual method_ with the same signature. A virtual method declaration introduces a new method. An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.

An _abstract method_ is a _virtual method_ with no implementation. An abstract method is declared with the abstract modifier and is permitted only in an abstract class. An abstract method must be overridden in every non-abstract derived class.

The following example declares an abstract class, Expression, which represents an expression tree node, and three derived classes, Constant, VariableReference, and Operation, which implement expression tree nodes for constants, variable references, and arithmetic operations. (This example is similar to, but not related to the expression tree types).

```csharp
public abstract class Expression
{
    public abstract double Evaluate(Dictionary<string, object> vars);
}

public class Constant : Expression
{
    double _value;

    public Constant(double value)
    {
        _value = value;
    }

    public override double Evaluate(Dictionary<string, object> vars)
    {
        return _value;
    }
}

public class VariableReference : Expression
{
    string _name;

    public VariableReference(string name)
    {
        _name = name;
    }

    public override double Evaluate(Dictionary<string, object> vars)
    {
        object value = vars[_name] ?? throw new Exception($"Unknown variable: {_name}");
        return Convert.ToDouble(value);
    }
}

public class Operation : Expression
{
    Expression _left;
    char _op;
    Expression _right;

    public Operation(Expression left, char op, Expression right)
    {
        _left = left;
        _op = op;
        _right = right;
    }

    public override double Evaluate(Dictionary<string, object> vars)
    {
        double x = _left.Evaluate(vars);
        double y = _right.Evaluate(vars);
        switch (_op)
        {
            case '+': return x + y;
            case '-': return x - y;
            case '*': return x * y;
            case '/': return x / y;

            default: throw new Exception("Unknown operator");
        }
    }
}
```

The previous four classes can be used to model arithmetic expressions. For example, using instances of these classes, the expression x + 3 can be represented as follows.

```csharp
Expression e = new Operation(
    new VariableReference("x"),
    '+',
    new Constant(3));
```

The _Evaluate_ method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value. The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries). Because _Evaluate_ is an abstract method, non-abstract classes derived from `Expression` must override _Evaluate_.

A _Constant_'s implementation of `Evaluate` simply returns the stored constant. A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value. An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.

The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.

```csharp
Expression e = new Operation(
    new VariableReference("x"),
    '*',
    new Operation(
        new VariableReference("y"),
        '+',
        new Constant(2)
    )
);
Dictionary<string, object> vars = new();
vars["x"] = 3;
vars["y"] = 5;
Console.WriteLine(e.Evaluate(vars)); // "21"
vars["x"] = 1.5;
vars["y"] = 9;
Console.WriteLine(e.Evaluate(vars)); // "16.5"
```

#### Method overloading

_Method overloading_ permits multiple methods in the same class to have the same name as long as they have unique signatures.

- When compiling an invocation of an _overloaded_ method, the compiler uses overload resolution to determine the specific method to invoke.
- _Overload_ resolution finds the one method that best matches the arguments. If no single best match can be found, an error is reported.

The following example shows overload resolution in effect. The comment for each invocation in the UsageExample method shows which method is invoked.

```csharp
class OverloadingExample
{
    static void F() => Console.WriteLine("F()");
    static void F(object x) => Console.WriteLine("F(object)");
    static void F(int x) => Console.WriteLine("F(int)");
    static void F(double x) => Console.WriteLine("F(double)");
    static void F<T>(T x) => Console.WriteLine($"F<T>(T), T is {typeof(T)}");
    static void F(double x, double y) => Console.WriteLine("F(double, double)");

    public static void UsageExample()
    {
        F();            // Invokes F()
        F(1);           // Invokes F(int)
        F(1.0);         // Invokes F(double)
        F("abc");       // Invokes F<T>(T), T is System.String
        F((double)1);   // Invokes F(double)
        F((object)1);   // Invokes F(object)
        F<int>(1);      // Invokes F<T>(T), T is System.Int32
        F(1, 1);        // Invokes F(double, double)
    }
}
```

As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.

### Events

An _event_ is a member that enables a class or object to provide notifications. An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.

Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors). The field stores a reference to a delegate that represents the event handlers that have been added to the event. If no event handlers are present, the field is `null`.

- The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list or a list item has been changed using the indexer set accessor.
- The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present). The notion of raising an event is precisely equivalent to invoking the delegate represented by the event. There are no special language constructs for raising events.

Clients react to events through event handlers. Event handlers are attached using the `+=` operator and removed using the `-=` operator.

The following example attaches an event handler to the Changed event of a `MyList<string>`.

```csharp
class EventExample
{
    static int s_changeCount;

    static void ListChanged(object sender, EventArgs e)
    {
        s_changeCount++;
    }

    public static void Usage()
    {
        var names = new MyList<string>();
        names.Changed += new EventHandler(ListChanged);
        names.Add("Liz");
        names.Add("Martha");
        names.Add("Beth");
        Console.WriteLine(s_changeCount); // "3"
    }
}
```

For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.
